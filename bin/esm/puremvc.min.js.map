{"version":3,"file":"puremvc.min.js","sources":["../../src/patterns/observer/Observer.js","../../src/core/View.js","../../src/core/Controller.js","../../src/core/Model.js","../../src/patterns/observer/Notification.js","../../src/patterns/facade/Facade.js","../../src/patterns/observer/Notifier.js","../../src/patterns/command/SimpleCommand.js","../../src/patterns/command/MacroCommand.js","../../src/patterns/mediator/Mediator.js","../../src/patterns/proxy/Proxy.js"],"sourcesContent":["/*\n *  Observer.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\n/**\n * A base `Observer` implementation.\n *\n * <P>An `Observer` is an object that encapsulates information\n * about an interested object with a method that should\n * be called when a particular `Notification` is broadcast.</P>\n *\n * <P>In PureMVC, the `Observer` class assumes these responsibilities:</P>\n *\n * <UL>\n * <LI>Encapsulate the notification (callback) method of the interested object.</LI>\n * <LI>Encapsulate the notification context (this) of the interested object.</LI>\n * <LI>Provide methods for setting the notification method and context.</LI>\n * <LI>Provide a method for notifying the interested object.</LI>\n * </UL>\n *\n * @class Observer\n */\nclass Observer {\n\n    /**\n     * Constructor.\n     *\n     * <P>The notification method on the interested object should take\n     * one parameter of type `Notification`</P>\n     *\n     * @param {function(Notification):void} notifyMethod\n     * @param {Object} notifyContext\n     */\n    constructor(notifyMethod, notifyContext) {\n        this._notifyMethod = notifyMethod;\n        this._notifyContext = notifyContext;\n    }\n\n    /**\n     * Notify the interested object.\n     *\n     * @param {Notification} notification\n     */\n    notifyObserver(notification) {\n        this._notifyMethod.call(this._notifyContext, notification);\n    }\n\n    /**\n     * Compare an object to the notification context.\n     *\n     * @param {Object} notifyContext\n     * @returns {boolean}\n     */\n    compareNotifyContext(notifyContext) {\n        return this._notifyContext === notifyContext;\n    }\n\n    /**\n     * Get the notification method.\n     *\n     * @returns {function(Notification):void}\n     */\n    get notifyMethod() {\n        return this._notifyMethod\n    }\n\n    /**\n     * Set the notification method.\n     *\n     * <P>The notification method should take one parameter of type `Notification`.</P>\n     *\n     * @param {function(Notification): void} notifyMethod - The function to be called when a notification is received.\n     */\n    set notifyMethod(notifyMethod) {\n        this._notifyMethod = notifyMethod;\n    }\n\n    /**\n     * Get the notifyContext\n     *\n     * @returns {Object}\n     */\n    get notifyContext() {\n        return this._notifyContext;\n    }\n\n    /**\n     * Set the notification context.\n     *\n     * @param {Object} notifyContext\n     */\n    set notifyContext(notifyContext) {\n        this._notifyContext = notifyContext;\n    }\n\n}\nexport { Observer }\n","/*\n *  View.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\nimport {Observer} from \"../patterns/observer/Observer.js\";\n\n/**\n * A Multiton `View` implementation.\n *\n * <P>In PureMVC, the `View` class assumes these responsibilities:</P>\n *\n * <UL>\n * <LI>Maintain a cache of `Mediator` instances.</LI>\n * <LI>Provide methods for registering, retrieving, and removing `Mediators`.</LI>\n * <LI>Notifying `Mediators` when they are registered or removed.</LI>\n * <LI>Managing the observer lists for each `Notification` in the application.</LI>\n * <LI>Providing a method for attaching `Observers` to a `Notification`'s observer list.</LI>\n * <LI>Providing a method for broadcasting a `Notification`.</LI>\n * <LI>Notifying the `Observers` of a given `Notification` when it broadcast.</LI>\n * </UL>\n *\n * @see Mediator Mediator\n * @see Observer Observer\n * @see Notification Notification\n *\n * @class View\n */\nclass View {\n\n    /**\n     * Constructor.\n     *\n     * <P>This `View` implementation is a Multiton,\n     * so you should not call the constructor\n     * directly, but instead call the static Multiton\n     * Factory method `View.getInstance( multitonKey )`\n     *\n     * @constructor\n     * @param {string} key\n     *\n     * @throws {Error} Error if instance for this Multiton key has already been constructed\n     */\n    constructor(key) {\n        if (View.instanceMap.get(key) != null) throw new Error(View.MULTITON_MSG);\n        /** @protected\n         * @type {string} */\n        this.multitonKey = key;\n        View.instanceMap.set(this.multitonKey, this);\n        /** @protected\n         * @type {Map<string, Mediator>} */\n        this.mediatorMap = new Map();\n        /** @protected\n         * @type {Map.<string, Array.<Observer>>} */\n        this.observerMap = new Map();\n        this.initializeView();\n    }\n\n    /**\n     * <P>Initialize the Multiton View instance.</P>\n     *\n     * <P>Called automatically by the constructor, this\n     * is your opportunity to initialize the Multiton\n     * instance in your subclass without overriding the\n     * constructor.</P>\n     */\n    initializeView() {\n\n    }\n\n    /**\n     * View Multiton factory method.\n     *\n     * @static\n     * @param {string} key\n     * @param {function(string):View} factory\n     * @returns {View} the Multiton instance of `View`\n     */\n    static getInstance(key, factory) {\n        if (View.instanceMap == null)\n            /** @static\n             * @type {Map<string, View>} */\n            View.instanceMap = new Map();\n        if (View.instanceMap.get(key) == null) View.instanceMap.set(key, factory(key));\n        return View.instanceMap.get(key);\n    }\n\n    /**\n     * <P>Register an `Observer` to be notified\n     * of `Notifications` with a given name.</P>\n     *\n     * @param {string} notificationName the name of the `Notifications` to notify this `Observer` of\n     * @param {Observer} observer the `Observer` to register\n     */\n    registerObserver(notificationName, observer) {\n        if (this.observerMap.get(notificationName) != null) {\n            let observers = this.observerMap.get(notificationName);\n            observers.push(observer);\n        } else {\n            this.observerMap.set(notificationName, new Array(observer));\n        }\n    }\n\n    /**\n     * <P>Notify the `Observers` for a particular `Notification`.</P>\n     *\n     * <P>All previously attached `Observers` for this `Notification`'s\n     * list are notified and are passed a reference to the `Notification` in\n     * the order in which they were registered.</P>\n     *\n     * @param {Notification} notification the `Notification` to notify `Observers` of.\n     */\n    notifyObservers(notification) {\n        if (this.observerMap.has(notification.name)) {\n            // Copy observers from reference array to working array,\n            // since the reference array may change during the notification loop\n            let observers = this.observerMap.get(notification.name).slice();\n\n            // Notify Observers from the working array\n            for(let i = 0; i < observers.length; i++) {\n                observers[i].notifyObserver(notification);\n            }\n        }\n    }\n\n    /**\n     * <P>Remove the observer for a given notifyContext from an observer list for a given Notification name.</P>\n     *\n     * @param {string} notificationName which observer list to remove from\n     * @param {Object} notifyContext remove the observer with this object as its notifyContext\n     */\n    removeObserver(notificationName, notifyContext) {\n        // the observer list for the notification under inspection\n        let observers = this.observerMap.get(notificationName);\n\n        // find the observer for the notifyContext\n        for (let i = 0; i < observers.length; i++) {\n            if (observers[i].compareNotifyContext(notifyContext) === true) {\n                // there can only be one Observer for a given notifyContext\n                // in any given Observer list, so remove it and break\n                observers.splice(i, 1);\n                break;\n            }\n        }\n\n        // Also, when a Notification's Observer list length falls to\n        // zero, delete the notification key from the observer map\n        if (observers.length === 0) {\n            this.observerMap.delete(notificationName);\n        }\n    }\n\n    /**\n     * Register a `Mediator` instance with the `View`.\n     *\n     * <P>Registers the `Mediator` so that it can be retrieved by name,\n     * and further interrogates the `Mediator` for its\n     * `Notification` interests.</P>\n     *\n     * <P>If the `Mediator` returns any `Notification`\n     * names to be notified about, an `Observer` is created encapsulating\n     * the `Mediator` instance's `handleNotification` method\n     * and registering it as an `Observer` for all `Notifications` the\n     * `Mediator` is interested in.</p>\n     *\n     * @param {Mediator} mediator a reference to the `Mediator` instance\n     */\n    registerMediator(mediator) {\n        // do not allow re-registration (you must to removeMediator fist)\n        if (this.mediatorMap.has(mediator.mediatorName) !== false) return;\n\n        mediator.initializeNotifier(this.multitonKey);\n\n        // Register the Mediator for retrieval by name\n        this.mediatorMap.set(mediator.mediatorName, mediator);\n\n        // Get Notification interests, if any.\n        let interests = mediator.listNotificationInterests();\n\n        // Register Mediator as an observer for each notification of interests\n        if (interests.length > 0) {\n            // Create Observer referencing this mediator's handleNotification method\n            let observer = new Observer(mediator.handleNotification.bind(mediator), mediator); // check bind\n\n            // Register Mediator as Observer for its list of Notification interests\n            for (let i = 0; i < interests.length; i++) {\n                this.registerObserver(interests[i], observer);\n            }\n        }\n\n        // alert the mediator that it has been registered\n        mediator.onRegister();\n    }\n\n    /**\n     * Retrieve a `Mediator` from the `View`.\n     *\n     * @param {string} mediatorName the name of the `Mediator` instance to retrieve.\n     * @returns {Mediator} the `Mediator` instance previously registered with the given `mediatorName`.\n     */\n    retrieveMediator(mediatorName) {\n        return this.mediatorMap.get(mediatorName) || null;\n    }\n\n    /**\n     * Remove a `Mediator` from the `View`.\n     *\n     * @param {string} mediatorName name of the `Mediator` instance to be removed.\n     * @returns {Mediator} the `Mediator` that was removed from the `View`\n     */\n    removeMediator(mediatorName) {\n        // Retrieve the named mediator\n        let mediator = this.mediatorMap.get(mediatorName);\n\n        if (mediator) {\n            // for every notification this mediator is interested in...\n            let interests = mediator.listNotificationInterests();\n            for (let i = 0; i < interests.length; i++) {\n                // remove the observer linking the mediator\n                // to the notification interest\n                this.removeObserver(interests[i], mediator);\n            }\n\n            // remove the mediator from the map\n            this.mediatorMap.delete(mediatorName);\n\n            // alert the mediator that it has been removed\n            mediator.onRemove();\n        }\n\n        return mediator;\n    }\n\n    /**\n     * Check if a Mediator is registered or not\n     *\n     * @param {string} mediatorName\n     * @returns {boolean} whether a Mediator is registered with the given `mediatorName`.\n     */\n    hasMediator(mediatorName) {\n        return this.mediatorMap.has(mediatorName);\n    }\n\n    /**\n     * Remove a View instance\n     *\n     * @static\n     * @param key multitonKey of View instance to remove\n     */\n    static removeView(key) {\n        this.instanceMap.delete(key);\n    }\n\n    /**\n     * Message Constants\n     *\n     * @static\n     * @type {string}\n     */\n    static get MULTITON_MSG() { return \"View instance for this Multiton key already constructed!\" };\n\n}\nexport { View }\n","/*\n *  Controller.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\nimport {View} from \"./View.js\"\nimport {Observer} from \"../patterns/observer/Observer.js\";\n\n/**\n * A Multiton `Controller` implementation.\n *\n * <P>In PureMVC, the `Controller` class follows the\n * 'Command and Controller' strategy, and assumes these\n * responsibilities:</P>\n *\n * <UL>\n * <LI> Remembering which `Command`s\n * are intended to handle which `Notifications`.</LI>\n * <LI> Registering itself as an `Observer` with\n * the `View` for each `Notification`\n * that it has a `Command` mapping for.</LI>\n * <LI> Creating a new instance of the proper `Command`\n * to handle a given `Notification` when notified by the `View`.</LI>\n * <LI> Calling the `Command`'s `execute`\n * method, passing in the `Notification`.</LI>\n * </UL>\n *\n * <P>Your application must register `Commands` with the\n * Controller.</P>\n *\n * <P>The simplest way is to subclass `Facade`,\n * and use its `initializeController` method to add your\n * registrations.</P>\n *\n * @see View View\n * @see Observer Observer\n * @see Notification Notification\n * @see SimpleCommand SimpleCommand\n * @see MacroCommand MacroCommand\n *\n * @class Controller\n */\nclass Controller {\n\n    /**\n     * Constructor.\n     *\n     * <P>This `Controller` implementation is a Multiton,\n     * so you should not call the constructor\n     * directly, but instead call the static Factory method,\n     * passing the unique key for this instance\n     * `Controller.getInstance( multitonKey )`</P>\n     *\n     * @throws {Error} Error if instance for this Multiton key has already been constructed\n     *\n     * @constructor\n     * @param {string} key\n     */\n    constructor(key) {\n        if (Controller.instanceMap[key] != null) throw new Error(Controller.MULTITON_MSG);\n        /** @protected\n         * @type {string} */\n        this.multitonKey = key;\n        Controller.instanceMap.set(this.multitonKey, this);\n        /** @protected\n         * @type {Map<string, function():SimpleCommand>} */\n        this.commandMap = new Map();\n        this.initializeController();\n    }\n\n    /**\n     * Initialize the Multiton `Controller` instance.\n     *\n     * <P>Called automatically by the constructor.</P>\n     *\n     * <P>Note that if you are using a subclass of `View`\n     * in your application, you should <i>also</i> subclass `Controller`\n     * and override the `initializeController` method in the\n     * following way:</P>\n     *\n     * <pre>`\n     *\t\t// ensure that the Controller is talking to my View implementation\n     *\t\tinitializeController( )\n     *\t\t{\n     *\t\t\tthis.view = MyView.getInstance(this.multitonKey, (key) => new MyView(key));\n     *\t\t}\n     * `</pre>\n     *\n     */\n    initializeController() {\n        /** @protected\n         * @type {View} **/\n        this.view = View.getInstance(this.multitonKey, (key) => new View(key));\n    }\n\n    /**\n     * `Controller` Multiton Factory method.\n     *\n     * @static\n     * @param {string} key\n     * @param {function(string):Controller} factory\n     * @returns {Controller} the Multiton instance of `Controller`\n     */\n    static getInstance(key, factory) {\n        if (Controller.instanceMap == null)\n            /** @static\n             @type {Map<string, Controller>} */\n            Controller.instanceMap = new Map();\n        if (Controller.instanceMap.get(key) == null) Controller.instanceMap.set(key, factory(key));\n        return Controller.instanceMap.get(key);\n    }\n\n    /**\n     * <P>If a `Command` has previously been registered\n     * to handle the given `Notification`, then it is executed.</P>\n     *\n     * @param {Notification} notification a `Notification`\n     */\n    executeCommand(notification) {\n        let factory = this.commandMap.get(notification.name);\n        if (factory == null) return;\n\n        let commandInstance = factory();\n        commandInstance.initializeNotifier(this.multitonKey);\n        commandInstance.execute(notification);\n    }\n\n    /**\n     * <P>Register a particular `Command` class as the handler\n     * for a particular `Notification`.</P>\n     *\n     * <P>If an `Command` has already been registered to\n     * handle `Notification`s with this name, it is no longer\n     * used, the new `Command` is used instead.</P>\n     *\n     * <P>The Observer for the new Command is only created if this the\n     * first time a Command has been registered for this Notification name.</P>\n     *\n     * @param notificationName the name of the `Notification`\n     * @param {function():SimpleCommand} factory\n     */\n    registerCommand(notificationName, factory) {\n        if (this.commandMap.get(notificationName) == null) {\n            this.view.registerObserver(notificationName, new Observer(this.executeCommand, this));\n        }\n        this.commandMap.set(notificationName, factory);\n    }\n\n    /**\n     * Check if a Command is registered for a given Notification\n     *\n     * @param {string} notificationName\n     * @return {boolean} whether a Command is currently registered for the given `notificationName`.\n     */\n    hasCommand(notificationName) {\n        return this.commandMap.has(notificationName);\n    }\n\n    /**\n     * Remove a previously registered `Command` to `Notification` mapping.\n     *\n     * @param {string} notificationName the name of the `Notification` to remove the `Command` mapping for\n     */\n    removeCommand(notificationName) {\n        // if the Command is registered...\n        if(this.hasCommand(notificationName)) {\n            // remove the observer\n            this.view.removeObserver(notificationName, this);\n\n            // remove the command\n            this.commandMap.delete(notificationName)\n        }\n    }\n\n    /**\n     * Remove a Controller instance\n     *\n     * @static\n     * @param {string} key of Controller instance to remove\n     */\n    static removeController(key) {\n        Controller.instanceMap.delete(key);\n    }\n\n    /**\n     * Message Constants\n     *\n     * @static\n     * @type {string}\n     */\n    static get MULTITON_MSG() { return \"Controller instance for this Multiton key already constructed!\" };\n}\nexport { Controller }\n","/*\n *  Model.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\n/**\n * A Multiton `Model` implementation.\n *\n * <P>In PureMVC, the `Model` class provides\n * access to model objects (Proxies) by named lookup.\n *\n * <P>The `Model` assumes these responsibilities:</P>\n *\n * <UL>\n * <LI>Maintain a cache of `Proxy` instances.</LI>\n * <LI>Provide methods for registering, retrieving, and removing\n * `Proxy` instances.</LI>\n * </UL>\n *\n * <P>Your application must register `Proxy` instances\n * with the `Model`. Typically, you use an\n * `Command` to create and register `Proxy`\n * instances once the `Facade` has initialized the Core\n * actors.</p>\n *\n * @see Proxy Proxy\n *\n * @class Model\n */\n\nclass Model {\n\n    /**\n     * Constructor.\n     *\n     * <P>This `Model` implementation is a Multiton,\n     * so you should not call the constructor\n     * directly, but instead call the static Multiton\n     * Factory method `Model.getInstance( multitonKey )`\n     *\n     * @constructor\n     * @param {string} key\n     *\n     * @throws {Error} Error if instance for this Multiton key instance has already been constructed\n     */\n    constructor(key) {\n        if (Model.instanceMap.get(key) != null) throw new Error(Model.MULTITON_MSG);\n        /** @protected\n         * @type {string} */\n        this.multitonKey = key;\n        Model.instanceMap.set(this.multitonKey, this);\n        /** @protected\n         * @type {Map<string, Proxy>} */\n        this.proxyMap = new Map();\n        this.initializeModel();\n    }\n\n    /**\n     * Initialize the `Model` instance.\n     *\n     * <P>Called automatically by the constructor, this\n     * is your opportunity to initialize the Multiton\n     * instance in your subclass without overriding the\n     * constructor.</P>\n     *\n     */\n    initializeModel() {\n\n    }\n\n    /**\n     * `Model` Multiton Factory method.\n     *\n     * @static\n     * @param {string} key\n     * @param {function(string):Model} factory\n     * @returns {Model} the instance for this Multiton key\n     */\n    static getInstance(key, factory) {\n        if (Model.instanceMap == null)\n            /** @static\n             @type {Map<string, Model>} */\n            Model.instanceMap = new Map();\n        if (Model.instanceMap.get(key) == null) Model.instanceMap.set(key, factory(key));\n        return Model.instanceMap.get(key);\n    }\n\n    /**\n     * Register a `Proxy` with the `Model`.\n     *\n     * @param {Proxy} proxy a `Proxy` to be held by the `Model`.\n     */\n    registerProxy(proxy) {\n        proxy.initializeNotifier(this.multitonKey);\n        this.proxyMap.set(proxy.proxyName, proxy);\n        proxy.onRegister();\n    }\n\n    /**\n     * Retrieve a `Proxy` from the `Model`.\n     *\n     * @param {string} proxyName\n     * @returns {Proxy} the `Proxy` instance previously registered with the given `proxyName`.\n     */\n    retrieveProxy(proxyName) {\n        return this.proxyMap.get(proxyName) || null;\n    }\n\n    /**\n     * Check if a Proxy is registered\n     *\n     * @param {string} proxyName\n     * @returns {boolean} whether a Proxy is currently registered with the given `proxyName`.\n     */\n    hasProxy(proxyName) {\n        return this.proxyMap.has(proxyName);\n    }\n\n    /**\n     * Remove a `Proxy` from the `Model`.\n     *\n     * @param {string} proxyName name of the `Proxy` instance to be removed.\n     * @returns {Proxy} the `Proxy` that was removed from the `Model`\n     */\n    removeProxy(proxyName) {\n        let proxy = this.proxyMap.get(proxyName);\n        if (proxy != null) {\n            this.proxyMap.delete(proxyName);\n            proxy.onRemove();\n        }\n        return proxy;\n    }\n\n    /**\n     * Remove a Model instance\n     *\n     * @static\n     * @param key\n     */\n    static removeModel(key) {\n        Model.instanceMap.delete(key);\n    }\n\n    /**\n     * @static\n     * @type {string}\n     */\n    static get MULTITON_MSG() { return \"Model instance for this Multiton key already constructed!\" };\n}\nexport { Model }","/*\n *  Notification.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\n/**\n *\n * A base `Notification` implementation.\n *\n * <P>PureMVC does not rely upon underlying event models such\n * as the one provided with Flash, and ActionScript 3 does\n * not have an inherent event model.</P>\n *\n * <P>The Observer Pattern as implemented within PureMVC exists\n * to support event-driven communication between the\n * application and the actors of the MVC triad.</P>\n *\n * <P>Notifications are not meant to be a replacement for Events\n * in Flex/Flash/Apollo. Generally, `Mediator` implementors\n * place event listeners on their view components, which they\n * then handle in the usual way. This may lead to the broadcast of `Notification`s to\n * trigger `Command`s or to communicate with other `Mediators`. `Proxy` and `Command`\n * instances communicate with each other and `Mediator`s\n * by broadcasting `Notification`s.</P>\n *\n * <P>A key difference between Flash `Event`s and PureMVC\n * `Notification`s is that `Event`s follow the\n * 'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy\n * until some parent component handles the `Event`, while\n * PureMVC `Notification`s follow a 'Publish/Subscribe'\n * pattern. PureMVC classes need not be related to each other in a\n * parent/child relationship in order to communicate with one another\n * using `Notification`s.</P>\n *\n * @class Notification\n */\nclass Notification {\n\n    /**\n     * Constructor.\n     *\n     * @constructor\n     * @param {string} name - The name of the notification.\n     * @param {Object|null} [body=null] - The body of the notification, defaults to `null`.\n     * @param {string} [type=\"\"] - The type of the notification, defaults to an empty string.\n     */\n    constructor(name, body = null, type = \"\") {\n        this._name = name;\n        this._body = body;\n        this._type = type;\n    }\n\n    /**\n     * Get the name of the `Notification` instance.\n     *\n     * @returns {string}\n     */\n    get name() {\n        return this._name;\n    }\n\n    /**\n     * Get the body of the `Notification` instance.\n     *\n     * @returns {Object}\n     */\n    get body() {\n        return this._body;\n    }\n\n    /**\n     * Set the body of the `Notification` instance.\n     *\n     * @param {Object|null} body\n     */\n    set body(body) {\n        this._body = body;\n    }\n\n    /**\n     * Get the type of the `Notification` instance.\n     *\n     * @returns {string}\n     */\n    get type() {\n        return this._type;\n    }\n\n    /**\n     * Set the type of the `Notification` instance.\n     *\n     * @param {string} type\n     */\n    set type(type) {\n        this._type = type;\n    }\n\n    /**\n     * Get the string representation of the `Notification` instance.\n     *\n     * @returns {string}\n     */\n    toString() {\n        let str= \"Notification Name: \" + this.name;\n        str+= \"\\nBody:\" + ((this.body == null ) ? \"null\" : this.body.toString());\n        str+= \"\\nType:\" + ((this.type == null ) ? \"null\" : this.type);\n        return str;\n    }\n\n}\nexport { Notification }\n","/*\n *  Facade.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\nimport {Controller} from \"../../core/Controller.js\";\nimport {Model} from \"../../core/Model.js\";\nimport {View} from \"../../core/View.js\";\nimport {Notification} from \"../observer/Notification.js\";\n\n/**\n * A base Multiton `Facade` implementation.\n *\n * @see Model Model\n * @see View View\n * @see Controller Controller\n *\n * @class Facade\n */\nclass Facade {\n\n    /**\n     * Constructor.\n     *\n     * <P>This `Facade` implementation is a Multiton,\n     * so you should not call the constructor\n     * directly, but instead call the static Factory method,\n     * passing the unique key for this instance\n     * `Facade.getInstance( multitonKey )`</P>\n     *\n     * @constructor\n     * @param {string} key\n     * @throws {Error} Error if instance for this Multiton key has already been constructed\n     */\n    constructor(key) {\n        if (Facade.instanceMap[key] != null) throw new Error(Facade.MULTITON_MSG);\n        this.initializeNotifier(key);\n        Facade.instanceMap.set(this.multitonKey, this);\n        this.initializeFacade();\n    }\n\n    /**\n     * Initialize the Multiton `Facade` instance.\n     *\n     * <P>Called automatically by the constructor. Override in your\n     * subclass to do any subclass specific initializations. Be\n     * sure to call `super.initializeFacade()`, though.</P>\n     */\n    initializeFacade() {\n        this.initializeModel();\n        this.initializeController();\n        this.initializeView();\n    }\n\n    /**\n     * Facade Multiton Factory method\n     *\n     * @static\n     * @param {string} key\n     * @param {function(string):Facade} factory\n     * @returns {Facade} the Multiton instance of the Facade\n     */\n    static getInstance(key, factory) {\n        if (Facade.instanceMap == null)\n            /** @static\n             * @type {Map<string, Facade>} */\n            Facade.instanceMap = new Map();\n        if (Facade.instanceMap.get(key) == null) Facade.instanceMap.set(key, factory(key));\n        return Facade.instanceMap.get(key);\n    }\n\n    /**\n     * Initialize the `Model`.\n     *\n     * <P>Called by the `initializeFacade` method.\n     * Override this method in your subclass of `Facade`\n     * if one or both of the following are true:</P>\n     *\n     * <UL>\n     * <LI> You wish to initialize a different `Model`.</LI>\n     * <LI> You have `Proxy`s to register with the Model that do not\n     * retrieve a reference to the Facade at construction time.`</LI>\n     * </UL>\n     *\n     * If you don't want to initialize a different `Model`,\n     * call `super.initializeModel()` at the beginning of your\n     * method, then register `Proxy`s.\n     *\n     * <P>Note: This method is <i>rarely</i> overridden; in practice you are more\n     * likely to use a `Command` to create and register `Proxy`s\n     * with the `Model`, since `Proxy`s with mutable data will likely\n     * need to send `Notification`s and thus will likely want to fetch a reference to\n     * the `Facade` during their construction.</P>\n     */\n    initializeModel() {\n        if (this.model != null) return;\n        this.model = Model.getInstance(this.multitonKey, key => new Model(key));\n    }\n\n    /**\n     * Initialize the `Controller`.\n     *\n     * <P>Called by the `initializeFacade` method.\n     * Override this method in your subclass of `Facade`\n     * if one or both of the following are true:</P>\n     *\n     * <UL>\n     * <LI> You wish to initialize a different `Controller`.</LI>\n     * <LI> You have `Commands` to register with the `Controller` at startup.`. </LI>\n     * </UL>\n     *\n     * <P>If you don't want to initialize a different `Controller`,\n     * call `super.initializeController()` at the beginning of your\n     * method, then register `Command`s.</P>\n     */\n    initializeController() {\n        if (this.controller != null) return;\n        this.controller = Controller.getInstance(this.multitonKey, key => new Controller(key));\n    }\n\n    /**\n     * Initialize the `View`.\n     *\n     * <P>Called by the `initializeFacade` method.\n     * Override this method in your subclass of `Facade`\n     * if one or both of the following are true:</P>\n     *\n     * <UL>\n     * <LI> You wish to initialize a different `View`.</LI>\n     * <LI> You have `Observers` to register with the `View`</LI>\n     * </UL>\n     *\n     * <P>If you don't want to initialize a different `View`,\n     * call `super.initializeView()` at the beginning of your\n     * method, then register `Mediator` instances.</P>\n     *\n     * <P>Note: This method is <i>rarely</i> overridden; in practice you are more\n     * likely to use a `Command` to create and register `Mediator`s\n     * with the `View`, since `Mediator` instances will need to send\n     * `Notification`s and thus will likely want to fetch a reference\n     * to the `Facade` during their construction.</P>\n     */\n    initializeView() {\n        if (this.view != null) return;\n        this.view = View.getInstance(this.multitonKey, key => new View(key));\n    }\n\n    /**\n     * Register a `Command` with the `Controller` by Notification name.\n     *\n     * @param {string} notificationName the name of the `Notification` to associate the `Command` with\n     * @param {function():SimpleCommand} factory a reference to the factory of the `Command`\n     */\n    registerCommand(notificationName, factory) {\n        this.controller.registerCommand(notificationName, factory);\n    }\n\n    /**\n     * Check if a Command is registered for a given Notification\n     *\n     * @param {string} notificationName\n     * @returns {boolean} whether a Command is currently registered for the given `notificationName`.\n     */\n    hasCommand(notificationName) {\n        return this.controller.hasCommand(notificationName);\n    }\n\n    /**\n     * Remove a previously registered `Command` to `Notification` mapping from the Controller.\n     *\n     * @param {string} notificationName the name of the `Notification` to remove the `Command` mapping for\n     */\n    removeCommand(notificationName) {\n        this.controller.removeCommand(notificationName);\n    }\n\n    /**\n     * Register a `Proxy` with the `Model` by name.\n     *\n     * @param {Proxy} proxy the `Proxy` instance to be registered with the `Model`.\n     */\n    registerProxy(proxy) {\n        this.model.registerProxy(proxy);\n    }\n\n    /**\n     * Remove a `Proxy` from the `Model` by name.\n     *\n     * @param {string} proxyName the `Proxy` to remove from the `Model`.\n     * @returns {Proxy} the `Proxy` that was removed from the `Model`\n     */\n    removeProxy(proxyName) {\n        return this.model.removeProxy(proxyName);\n    }\n\n    /**\n     * Check if a Proxy is registered\n     *\n     * @param {string} proxyName\n     * @returns {boolean} whether a Proxy is currently registered with the given `proxyName`.\n     */\n    hasProxy(proxyName) {\n        return this.model.hasProxy(proxyName);\n    }\n\n    /**\n     * Retrieve a `Proxy` from the `Model` by name.\n     *\n     * @param {string} proxyName the name of the proxy to be retrieved.\n     * @returns {Proxy} the `Proxy` instance previously registered with the given `proxyName`.\n     */\n    retrieveProxy(proxyName) {\n        return this.model.retrieveProxy(proxyName);\n    }\n\n    /**\n     * Register a `Mediator` with the `View`.\n     *\n     * @param {Mediator} mediator a reference to the `Mediator`\n     */\n    registerMediator(mediator) {\n        this.view.registerMediator(mediator);\n    }\n\n    /**\n     * Remove a `Mediator` from the `View`.\n     *\n     * @param {string} mediatorName name of the `Mediator` to be removed.\n     * @returns {Mediator} the `Mediator` that was removed from the `View`\n     */\n    removeMediator(mediatorName) {\n        return this.view.removeMediator(mediatorName);\n    }\n\n    /**\n     * Check if a Mediator is registered or not\n     *\n     * @param {string} mediatorName\n     * @returns {boolean} whether a Mediator is registered with the given `mediatorName`.\n     */\n    hasMediator(mediatorName) {\n        return this.view.hasMediator(mediatorName);\n    }\n\n    /**\n     * Retrieve a `Mediator` from the `View`.\n     *\n     * @param {string} mediatorName\n     * @returns {Mediator} the `Mediator` previously registered with the given `mediatorName`.\n     */\n    retrieveMediator(mediatorName) {\n        return this.view.retrieveMediator(mediatorName);\n    }\n\n    /**\n     * Create and send an `Notification`.\n     *\n     * <P>Keeps us from having to construct new notification\n     * instances in our implementation code.</P>\n     *\n     * @param {string} notificationName the name of the notification to send\n     * @param {Object} [body] body the body of the notification (optional)\n     * @param {string} [type] type the type of the notification (optional)\n     */\n    sendNotification(notificationName, body = null, type = \"\") {\n        this.notifyObservers(new Notification(notificationName, body, type));\n    }\n\n    /**\n     * Notify `Observer`s.\n     *\n     * <P>This method is left public mostly for backward\n     * compatibility, and to allow you to send custom\n     * notification classes using the facade.</P>\n     *\n     * <P>Usually you should just call sendNotification\n     * and pass the parameters, never having to\n     * construct the notification yourself.</P>\n     *\n     * @param {Notification} notification the `Notification` to have the `View` notify `Observers` of.\n     */\n    notifyObservers(notification) {\n        this.view.notifyObservers(notification);\n    }\n\n    /**\n     * Set the Multiton key for this facade instance.\n     *\n     * <P>Not called directly, but instead from the\n     * constructor when getInstance is invoked.\n     * It is necessary to be public in order to\n     * implement Notifier.</P>\n     */\n    initializeNotifier(key) {\n        this.multitonKey = key;\n    }\n\n    /**\n     * Check if a Core is registered or not\n     *\n     * @static\n     * @param {string} key the multiton key for the Core in question\n     * @returns {boolean} whether a Core is registered with the given `key`.\n     */\n    static hasCore(key) {\n        return this.instanceMap.has(key);\n    }\n\n    /**\n     * Remove a Core.\n     *\n     * <P>Remove the Model, View, Controller and Facade\n     * instances for the given key.</P>\n     *\n     * @static\n     * @param {string} key multitonKey of the Core to remove\n     */\n    static removeCore(key) {\n        if (Facade.instanceMap.get(key) == null) return;\n        Model.removeModel(key);\n        View.removeView(key);\n        Controller.removeController(key);\n        this.instanceMap.delete(key);\n    }\n\n    /**\n     * Message Constants\n     *\n     * @static\n     * @returns {string}\n     */\n    static get MULTITON_MSG() {return \"Facade instance for this Multiton key already constructed!\"};\n}\nexport { Facade }\n","/*\n *  Notifier.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\nimport {Facade} from \"../facade/Facade.js\";\n\n/**\n * A Base `Notifier` implementation.\n *\n * <P>`MacroCommand, Command, Mediator` and `Proxy`\n * all have a need to send `Notifications`.<P>\n *\n * <P>The `Notifier` interface provides a common method called\n * `sendNotification` that relieves implementation code of\n * the necessity to actually construct `Notifications`.</P>\n *\n * <P>The `Notifier` class, which all the above-mentioned classes\n * extend, provides an initialized reference to the `Facade`\n * Multiton, which is required for the convenience method\n * for sending `Notifications`, but also eases implementation as these\n * classes have frequent `Facade` interactions and usually require\n * access to the facade anyway.</P>\n *\n * <P>NOTE: In the MultiCore version of the framework, there is one caveat to\n * notifiers, they cannot send notifications or reach the facade until they\n * have a valid multitonKey.</P>\n *\n * The multitonKey is set:\n *   * on a Command when it is executed by the Controller\n *   * on a Mediator is registered with the View\n *   * on a Proxy is registered with the Model.\n *\n * @see Proxy Proxy\n * @see Facade Facade\n * @see Mediator Mediator\n * @see MacroCommand MacroCommand\n * @see SimpleCommand SimpleCommand\n *\n * @class Notifier\n */\nclass Notifier {\n\n    constructor() {}\n\n    /**\n     * Create and send an `Notification`.\n     *\n     * <P>Keeps us from having to construct new Notification\n     * instances in our implementation code.</P>\n     *\n     * @param {string} notificationName\n     * @param {Object} [body] body\n     * @param {string} [type] type\n     */\n    sendNotification (notificationName, body = null, type = \"\") {\n        if (this.facade != null) {\n            this.facade.sendNotification(notificationName, body, type);\n        }\n    }\n\n    /**\n     * Initialize this Notifier instance.\n     *\n     * <P>This is how a Notifier gets its multitonKey.\n     * Calls to sendNotification or to access the\n     * facade will fail until after this method\n     * has been called.</P>\n     *\n     * <P>Mediators, Commands or Proxies may override\n     * this method in order to send notifications\n     * or access the Multiton Facade instance as\n     * soon as possible. They CANNOT access the facade\n     * in their constructors, since this method will not\n     * yet have been called.</P>\n     *\n     * @param {string} key the multitonKey for this Notifier to use\n     */\n    initializeNotifier(key) {\n        this.multitonKey = key;\n    }\n\n    /**\n     * Return the Multiton Facade instance\n     *\n     * @typedef {Facade} Facade\n     *\n     * @throws {Error}\n     */\n    get facade() {\n        if (this.multitonKey == null) throw new Error(Notifier.MULTITON_MSG);\n        return Facade.getInstance(this.multitonKey, key => new Facade(key));\n    }\n\n    /**\n     * Message Constants\n     *\n     * @static\n     * @returns {string}\n     */\n    static get MULTITON_MSG() { return \"multitonKey for this Notifier not yet initialized!\" }\n}\nexport { Notifier }\n","/*\n *  SimpleCommand.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\nimport {Notifier} from \"../observer/Notifier.js\";\n\n/**\n * A base `Command` implementation.\n *\n * <P>Your subclass should override the `execute`\n * method where your business logic will handle the `Notification`.</P>\n *\n * @see Controller Controller\n * @see Notification Notification\n * @see MacroCommand MacroCommand\n *\n * @class SimpleCommand\n */\nclass SimpleCommand extends Notifier {\n\n    constructor() {\n        super();\n    }\n\n    /**\n     * Fulfill the use-case initiated by the given `Notification`.\n     *\n     * <P>In the Command Pattern, an application use-case typically\n     * begins with some user action, which results in a `Notification` being broadcast, which\n     * is handled by business logic in the `execute` method of an\n     * `Command`.</P>\n     *\n     * @param {Notification} notification\n     */\n    execute(notification) {\n\n    }\n\n}\nexport { SimpleCommand }\n","/*\n *  MacroCommand.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\nimport {SimpleCommand} from \"./SimpleCommand.js\";\n\n/**\n * A base `Command` implementation that executes other `Command`s.\n *\n * <P>A `MacroCommand` maintains a list of\n * `Command` Class references called <i>SubCommands</i>.</P>\n *\n * <P>When `execute` is called, the `MacroCommand`\n * instantiates and calls `execute` on each of its <i>SubCommands</i> turn.\n * Each <i>SubCommand</i> will be passed a reference to the original\n * `Notification` that was passed to the `MacroCommand`'s\n * `execute` method.</P>\n *\n * <P>Unlike `SimpleCommand`, your subclass\n * should not override `execute`, but instead, should\n * override the `initializeMacroCommand` method,\n * calling `addSubCommand` once for each <i>SubCommand</i>\n * to be executed.</P>\n *\n * @see Controller Controller\n * @see Notification Notification\n * @see SimpleCommand SimpleCommand\n *\n * @class MacroCommand\n */\nclass MacroCommand extends SimpleCommand {\n\n    /**\n     * Constructor.\n     *\n     * <P>You should not need to define a constructor,\n     * instead, override the `initializeMacroCommand`\n     * method.</P>\n     *\n     * <P>If your subclass does define a constructor, be\n     * sure to call `super()`.</P>\n     *\n     * @constructor\n     */\n    constructor() {\n        super();\n        /** @protected\n         * @type {Array.<function():SimpleCommand>} */\n        this.subCommands = [];\n        this.initializeMacroCommand();\n    }\n\n    /**\n     * Initialize the `MacroCommand`.\n     *\n     * <P>In your subclass, override this method to\n     * initialize the `MacroCommand`'s <i>SubCommand</i>\n     * list with `Command` class references like\n     * this:</P>\n     *\n     * <pre>`\n     *\t\t// Initialize MyMacroCommand\n     *\t\tinitializeMacroCommand() {\n     *\t\t\tthis.addSubCommand(() => new app.FirstCommand());\n     *\t\t\tthis.addSubCommand(() => new app.SecondCommand());\n     *\t\t\tthis.addSubCommand(() => new app.ThirdCommand());\n     *\t\t}\n     * `</pre>\n     *\n     * <P>Note that <i>SubCommand</i>s may be any `Command` implementor,\n     * `MacroCommand`s or `SimpleCommands` are both acceptable.\n     */\n    initializeMacroCommand() {\n\n    }\n\n    /**\n     * Add a <i>SubCommand</i>.\n     *\n     * <P>The <i>SubCommands</i> will be called in First In/First Out (FIFO)\n     * order.</P>\n     *\n     * @param {function():SimpleCommand} factory\n     */\n    addSubCommand(factory) {\n        this.subCommands.push(factory);\n    }\n\n    /**\n     * Execute this `MacroCommand`'s <i>SubCommands</i>.\n     *\n     * <P>The <i>SubCommands</i> will be called in First In/First Out (FIFO)\n     * order.</P>\n     *\n     * @param {Notification} notification\n     */\n    execute(notification) {\n        while(this.subCommands.length > 0) {\n            let factory = this.subCommands.shift();\n            let commandInstance = factory();\n            commandInstance.initializeNotifier(this.multitonKey);\n            commandInstance.execute(notification);\n        }\n    }\n\n}\nexport { MacroCommand }\n","/*\n *  Mediator.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\nimport {Notifier} from \"../observer/Notifier.js\";\n\n/**\n * A base `Mediator` implementation.\n *\n * @see View View\n *\n * @class Mediator\n */\nclass Mediator extends Notifier {\n\n    /**\n     * Constructor.\n     *\n     * @constructor\n     * @param {string} mediatorName\n     * @param {Object} [viewComponent] viewComponent\n     */\n    constructor(mediatorName, viewComponent = null) {\n        super();\n        this._mediatorName = mediatorName || Mediator.NAME;\n        this._viewComponent = viewComponent;\n    }\n\n    /**\n     * Called by the View when the Mediator is registered\n     */\n    onRegister() {\n\n    }\n\n    /**\n     * Called by the View when the Mediator is removed\n     */\n    onRemove() {\n\n    }\n\n    /**\n     * List the `Notification` names this\n     * `Mediator` is interested in being notified of.\n     *\n     * @returns {string[]}\n     */\n    listNotificationInterests() {\n        return [];\n    }\n\n    /**\n     * Handle `Notification`s.\n     *\n     * <P>\n     * Typically this will be handled in a switch statement,\n     * with one 'case' entry per `Notification`\n     * the `Mediator` is interested in.\n     *\n     * @param {Notification} notification\n     */\n    handleNotification(notification) {\n\n    }\n\n    /**\n     * the mediator name\n     *\n     * @returns {string}\n     */\n    get mediatorName() {\n        return this._mediatorName;\n    }\n\n    /**\n     * Get the `Mediator`'s view component.\n     *\n     * <P>\n     * Additionally, an implicit getter will usually\n     * be defined in the subclass that casts the view\n     * object to a type, like this:</P>\n     *\n     * @returns {Object}\n     */\n    get viewComponent() {\n        return this._viewComponent;\n    }\n\n    /**\n     * Set the `Mediator`'s view component.\n     *\n     * @param {Object} viewComponent\n     */\n    set viewComponent(viewComponent) {\n        this._viewComponent = viewComponent;\n    }\n\n    /**\n     * The name of the `Mediator`.\n     *\n     * <P>Typically, a `Mediator` will be written to serve\n     * one specific control or group controls and so,\n     * will not have a need to be dynamically named.</P>\n     *\n     * @static\n     * @returns {string}\n     */\n    static get NAME() { return \"Mediator\" }\n}\nexport { Mediator }\n","/*\n *  Proxy.js\n *  PureMVC JavaScript Multicore\n *\n *  Copyright(c) 2023 Saad Shams <saad.shams@puremvc.org>\n *  Your reuse is governed by the BSD License\n*/\n\nimport {Notifier} from \"../observer/Notifier.js\";\n\n/**\n * A base `Proxy` implementation.\n *\n * <P>In PureMVC, `Proxy` classes are used to manage parts of the\n * application's data model. </P>\n *\n * <P>A `Proxy` might simply manage a reference to a local data object,\n * in which case interacting with it might involve setting and\n * getting of its data in synchronous fashion.</P>\n *\n * <P>`Proxy` classes are also used to encapsulate the application's\n * interaction with remote services to save or retrieve data, in which case,\n * we adopt an asynchronous idiom; setting data (or calling a method) on the\n * `Proxy` and listening for a `Notification` to be sent\n * when the `Proxy` has retrieved the data from the service. </P>\n *\n * @see Model Model\n *\n * @class Proxy\n */\nclass Proxy extends Notifier {\n    /**\n     * Constructor\n     *\n     * @constructor\n     * @param {string} proxyName\n     * @param {Object} [data]\n     */\n    constructor(proxyName, data = null) {\n        super();\n        /** @protected\n         * @type {string} */\n        this._proxyName = proxyName || Proxy.NAME;\n        /** @protected\n         * @type {Object} */\n        this._data = data;\n    }\n\n    /**\n     * Called by the Model when the Proxy is registered\n     */\n    onRegister() {}\n\n    /**\n     * Called by the Model when the Proxy is removed\n     */\n    onRemove() {}\n\n    /**\n     * Get the proxy name\n     *\n     * @returns {string}\n     */\n    get proxyName() {\n        return this._proxyName;\n    }\n\n    /**\n     * Get the data object\n     *\n     * @returns {Object}\n     */\n    get data () {\n        return this._data;\n    }\n\n    /**\n     * Set the data object\n     *\n     * @param {Object} data\n     */\n    set data(data) {\n        this._data = data;\n    }\n\n    /**\n     *\n     * @static\n     * @returns {string}\n     */\n    static get NAME() { return \"Proxy\" }\n}\nexport { Proxy }\n"],"names":["Observer","constructor","notifyMethod","notifyContext","this","_notifyMethod","_notifyContext","notifyObserver","notification","call","compareNotifyContext","View","key","instanceMap","get","Error","MULTITON_MSG","multitonKey","set","mediatorMap","Map","observerMap","initializeView","getInstance","factory","registerObserver","notificationName","observer","push","Array","notifyObservers","has","name","observers","slice","i","length","removeObserver","splice","delete","registerMediator","mediator","mediatorName","initializeNotifier","interests","listNotificationInterests","handleNotification","bind","onRegister","retrieveMediator","removeMediator","onRemove","hasMediator","removeView","Controller","commandMap","initializeController","view","executeCommand","commandInstance","execute","registerCommand","hasCommand","removeCommand","removeController","Model","proxyMap","initializeModel","registerProxy","proxy","proxyName","retrieveProxy","hasProxy","removeProxy","removeModel","Notification","body","type","_name","_body","_type","toString","str","Facade","initializeFacade","model","controller","sendNotification","hasCore","removeCore","Notifier","facade","SimpleCommand","super","MacroCommand","subCommands","initializeMacroCommand","addSubCommand","shift","Mediator","viewComponent","_mediatorName","NAME","_viewComponent","Proxy","data","_proxyName","_data"],"mappings":"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"}